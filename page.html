<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<style>
div{
position:absolute;
}


#container {
position: relative;
margin:0 auto;
background-color:green;
}

#stage {
position: absolute;
padding: 0px;
-ms-transform-origin: 0 0;
/* IE 9 */
            
-webkit-transform-origin: 0 0;
/* Chrome, Safari, Opera */
            
transform-origin: 0 0;
left: 0px;
top: 0px;
height: 720px;
width: 1280px;
background-color: silver;
/* show me! */
}

#gameView {
position:absolute;
width:100%;
height:100%;
max-width:100%;
max-height:100%;
overflow:hidden;
background-color:grey;
}

#map {
display:block;
position:absolute;
width:5000px;
height:5000px;
background-color:grey;
background-image:url('img/bg_pattern.jpg');
left:50%;
top:50%;
margin-left:-2500px;
margin-top:-2500px;
}


#moveObj {
//visibility:hidden;
display:block;
position:absolute;
left:300px;
top:300px;
height:100px;
width:100px;
background-color:red;

padding:0;


//max-height:100px;
margin-left:-50px;
margin-top:-50px;

border:2px solid black;

//change origin of rotation
//transform-origin: 50& 0%;
}


.opponentCar {
display:block;
position:absolute;
left:50%;
top:50%;
height:100px;
width:100px;
background-color:green;

padding:0;


//max-height:100px;
margin-left:-50px;
margin-top:-50px;

border:2px solid black;

//change origin of rotation
//transform-origin: 50& 0%;
}

.balloon{
width:120px;
height:120px;
top:100px;
left:-10px;
border-radius:50%;
background-color:pink;

}

.pin{
width:4px;
height:50px;
left:50%;
top:-50px;
margin-left:-2px;
background-color:black;
}



#go_animation {
display:none;
position:absolute;
left:100px;
top:300px;
width:100px;
height:50px;
background-color:blue;
}

#fps_log {
//z-index:9999;
position:absolute;
background-color:white;
width:200px;
height:200px;
border: 2px solid black;
}











.overlay {
            opacity: 1;
            background: -webkit-radial-gradient(0% 100%, ellipse cover, rgba(104,128,138,.4) 10%,rgba(138,114,76,0) 40%), linear-gradient(to bottom, rgba(57,173,219,.25) 0%,rgba(42,60,87,.4) 100%), linear-gradient(135deg, #670d10 0%,#092756 100%);
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0px;
            left: 0px;
            z-index: 1000;
			text-align:center;
        }
        .login {
            position: absolute; /* or absolute */
			padding:0;
		width:400px;
		height:400px;
  top: 15%;
  left: 50%;
  margin-left:-200px;
 
        }

#score{
bottom: 0;
    left: 0;
}
#leaderboard{
text-align:center;
top: 0;
right: 0;
}


#enter_link {
display:block;
position:absolute;
  -webkit-border-radius: 22;
  -moz-border-radius: 22;
  border-radius: 22px;
  font-family: Courier New;
  color: #ffffff;
  font-size: 26px;
  background: #4e5f6b;
  padding: 10px 20px 10px 20px;
  text-decoration: none;
  width:200px;
  left:50%;
  top:230px;
  margin:0;
  margin-left:-100px;
}

#enter_link:hover {
  background: #3cb0fd;
  background-image: -webkit-linear-gradient(top, #3cb0fd, #3498db);
  background-image: -moz-linear-gradient(top, #3cb0fd, #3498db);
  background-image: -ms-linear-gradient(top, #3cb0fd, #3498db);
  background-image: -o-linear-gradient(top, #3cb0fd, #3498db);
  background-image: linear-gradient(to bottom, #3cb0fd, #3498db);
  text-decoration: none;
}
.input {
  display: block;
  position:absolute;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  padding: 10px 20px;
  border: 1px solid #b7b7b7;
  -webkit-border-radius: 3px;
  border-radius: 3px;
  font: normal 16px/normal "Times New Roman", Times, serif;
  color: rgba(0,142,198,1);
  -o-text-overflow: clip;
  text-overflow: clip;
  background: rgba(252,252,252,1);
  -webkit-box-shadow: 2px 2px 2px 0 rgba(0,0,0,0.2) inset;
  box-shadow: 2px 2px 2px 0 rgba(0,0,0,0.2) inset;
  text-shadow: 1px 1px 0 rgba(255,255,255,0.66) ;
  -webkit-transition: all 200ms cubic-bezier(0.42, 0, 0.58, 1);
  -moz-transition: all 200ms cubic-bezier(0.42, 0, 0.58, 1);
  -o-transition: all 200ms cubic-bezier(0.42, 0, 0.58, 1);
  transition: all 200ms cubic-bezier(0.42, 0, 0.58, 1);
  width:200px;
  left:50%;
  margin:0;
  margin-left:-120px;
}

#miniMap{
position:absolute;
width:150px;
height:150px;
border:2px solid black;
bottom:10px;
right:20px;
background-color:green;

}

#mini_sprite{
position:absolute;
top:0px;
left:0px;
width:4px;
height:4px;
margin-left:-2px;
margin-top:-2px;
border:1px solid white;
background-color:white;
border-radius:50%;
}

.mini_otherCars{
position:absolute;
width:4px;
height:4px;
margin-left:-2px;
margin-top:-2px;
border:1px solid black;
border-radius:50%;
}

.player_name{
position:absolute;
transform:rotate(90deg);
height:20px;
width:100px;
left:-60px;
top:40px;
padding:0px;
font-size:18px;
}


.title{
font-size: 50px;
}
</style>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript" src="js/jquery-1.11.2.js"></script>
</head>
<body>
<div id="fps_log"></div>
<div id="container">
<div id="stage">




	<div id="splashscreen" class="overlay">
        <div class="login">
            <h1 class="title">RC POP</h1>
			<br/><br/>
                <input type="text" id="u" class="input" placeholder="Username" autofocus>
				<br/><br/>
                <button href="#"  id="enter_link">Play</button>
        </div>
        </div>  






<div id="gameView"><!-- gameView -->
<div id="map">
<div id="moveObj"><div class="pin"></div><div class="balloon"></div><div id="my_name" class="player_name">ma name Jeff</div></div>
</div>

<div id="miniMap"><div id="mini_sprite"></div></div>

</div><!-- gameView end -->
<div id="score">Score: 0</div>
		<div id="leaderboard">Leaderboard</div>

<div id="go_animation"></div>




<script>
//Server
var socket = io();

//UI
	$('#enter_link').click(function() {
          var nickname = $("#u").val();
          console.log(nickname);
          socket.emit('new client', nickname);
        });
		
	document.body.addEventListener("keydown", function(e) {
	if (!e) { 
		var e = window.event; 
	}
    // sometimes useful

    // Enter is pressed
	if (e.keyCode == 13) {
          var nickname = $("#u").val();
          console.log(nickname);
          socket.emit('new client', nickname);
	}
	}, false);
// End of UI














//define and initialize sprites here
var lastLoop = new Date;;//global fps tracking var
var real_fps = 1;//current running fps
var fps_barrier = 5;//stop rendering if drops below this number till becomes better
var fps = 30;//ideal game fps
var start_fps = 60;
var gameState = 0;//0 - game inactive; 1 - game active
var mouse_x = 0;
var mouse_y = 0;

//init end




//utility functions
function toRadians (angle) {
  return angle * (Math.PI / 180);
}


function toDegrees (angle) {
  return angle * (180 / Math.PI);
}


//determine current actual running fps
function trackFps(){
    thisLoop = new Date;
    real_fps = 1000 / (thisLoop - lastLoop);
    lastLoop = thisLoop;
}

//normalizes unit according to current fps
function normalize_unit(unit){
	return (unit * (fps/real_fps));
}














//sprite camera object
function SpriteCamera(sprite,map,x_bound,y_bound,camera_speed){
	c = this;
	c.targetSprite = sprite;
	c.xBound = x_bound;
	c.yBound = y_bound;
	//start with camera centered on sprite
	c.x = c.targetSprite.x - (c.xBound/2);
	c.y = c.targetSprite.y - (c.yBound/2);

	c.speed = camera_speed;

	c.map = map;//map element
	c.map.css({left:"50%",top:"50%"});
	c.mapX = c.map.position().left;
	c.mapY = c.map.position().top;

	map_w = c.map.width();
	map_h = c.map.height();
	
	center_c_x = (map_w/2) - c.targetSprite.x;
	center_c_y = (map_h/2) - c.targetSprite.y;
	new_map_x = c.mapX + center_c_x;
	new_map_y = c.mapY + center_c_y;

	c.map.css({ left : new_map_x, top : new_map_y });

	c.mapX = new_map_x;
	c.mapY = new_map_y;


	c.follow = 1;
}

SpriteCamera.prototype = {

FollowSprite : function(){
	c = this;

	if( (c.follow == false) ){
		return;
	}

	pathX = 0;
	pathY = 0;

	dx = c.targetSprite.x - c.x;
	dy = c.targetSprite.y - c.y;

	if(dx < 0){
		pathX = dx;
	}
	if(dx > c.xBound){
		pathX = dx - c.xBound;
	}
	if(dy < 0){
		pathY = dy;
	}
	if(dy > c.yBound){
		pathY = dy - c.yBound;
	}

	//no movement required
	if(pathX == 0 && pathY == 0){
		return;
	}

	moveUnitX = pathX;
	moveUnitY = pathY;

	
	//deprecated, in case need to have a camera move at a different speed
	speed = normalize_unit(c.speed);

        distance = Math.sqrt(pathX * pathX + pathY * pathY);
        directionX = pathX / distance;
        directionY = pathY / distance;

	moveUnitX = directionX * speed;
	moveUnitY = directionY * speed;

	//check overshoot
	if(Math.abs(moveUnitX) > Math.abs(pathX)){
		moveUnitX = pathX;
	}
	if(Math.abs(moveUnitY) > Math.abs(pathY)){
		moveUnitY = pathY;
	}
	

	new_cam_x = c.x + moveUnitX;
	new_cam_y = c.y + moveUnitY;

        new_map_x = c.mapX - moveUnitX;
        new_map_y = c.mapY - moveUnitY;

	c.map.css({ left : new_map_x, top : new_map_y });

	c.x = new_cam_x;
	c.y = new_cam_y;

	c.mapX = new_map_x;
	c.mapY = new_map_y;


},//FollowSprite end

setSpeed : function(speed){
	c = this;
	c.speed = speed;
},

toggleFollow : function(){
	c = this;
	c.follow = 1 - c.follow; //toggle camera follow
}

};





















//movement sprite object
function MoveSprite(elem){
	s = this;
	s.sprite = elem;
	s.speed = 0;// px per second
	s.x = $(s.sprite).position().left;
	s.y = $(s.sprite).position().top;
	s.targetX = s.x;
	s.targetY = s.y;
	s.rotateUnit = 5;
	s.orientation = 0;
	s.targetOrientation = 0;
	score = 0;
}


MoveSprite.prototype = {

setPos : function(x,y){
	s = this;
	s.x = x;
	s.y = y;
	s.sprite.css({left:x+"px", top:y+"px"});
},

setScore : function(score){
	c = this;
	c.score = score;
	$("#score").html("Score: "+score);
},

setSpeed : function(speed){

	s = this;
	s.speed = speed;

},//SetSpeed end

setRotateUnit : function(rotateUnit){

	s = this;
	s.rotateUnit = rotateUnit;

},//setRotateUnit end

moveTo : function(){

	s = this;
//s.sprite.css({'transform':'rotate(0deg)'});//prevent buggy position
	target_x = s.targetX;
	target_y = s.targetY;
	//return;//remove this
	if(s.x == target_x && s.y == target_y){
		return;
	}

	speed = normalize_unit(s.speed);

        pathX = target_x - s.x;
        pathY = target_y - s.y;

        distance = Math.sqrt(pathX * pathX + pathY * pathY);
        directionX = pathX / distance;
        directionY = pathY / distance;

        new_x = s.x + directionX * speed;
        new_y = s.y + directionY * speed;

	//check overshoot
	if(Math.abs(target_x - s.x) <= Math.abs(target_x - new_x)){
		new_x = target_x;
	}
	if(Math.abs(target_y - s.y) <= Math.abs(target_y - new_y)){
		new_y = target_y;
	}
	

	s.sprite.css({ left : new_x, top : new_y });

	s.x = new_x;//$(s.sprite).position().left;
	s.y = new_y;//$(s.sprite).position().top;

	return;
},//MoveTo end

//rotate towards given element
orientSprite : function(obj){
	s = this;
	s.sprite.css({'transform':'rotate('+s.orientation+'deg)'});

},//rotateTo end

moveInDirection : function(simulate){
	s = this;

	angle = s.orientation;
	speed = s.speed;

	if(s.x == s.targetX && s.y == s.targetY){
		return;
	}

	speed = normalize_unit(speed);

	
	move_x_unit = (speed * Math.sin(toRadians(angle)));
	move_y_unit = (speed * Math.cos(toRadians(angle)));

	new_x = s.x + move_x_unit;
	new_y = s.y - move_y_unit; 

	if( Math.abs(s.targetX - new_x) < speed && Math.abs(s.targetY - new_y) < speed ){
		s.x = s.targetX;
		s.y = s.targetY;
		return;
	}

	s.sprite.css({ left : new_x, top : new_y });

	s.x = new_x;//$(s.sprite).position().left;
	s.y = new_y;//$(s.sprite).position().top;



},//moveInDirection end

moveMap : function(map, target_x, target_y){

	s.targetX = target_x;
	s.targetY = target_y;
	//return;//remove this


	speed = normalize_unit(s.speed);


        pathX = target_x - s.x;
        pathY = target_y - s.y;

        distance = Math.sqrt(pathX * pathX + pathY * pathY);
        directionX = pathX / distance;
        directionY = pathY / distance;

        new_x = map.position().left + ((directionX * speed)*-1);
        new_y = map.position().top + ((directionY * speed)*-1);

	map.css({left:new_x+'px', top:new_y+'px'});
	

},//moveMap end

setTargetPos : function(target_x, target_y){

	s = this;
	s.targetX = target_x;
	s.targetY = target_y;

},//setTargetPos end

updateOrientation : function(){

	s = this;
	if(s.orientation == s.targetOrientation){
		return;
	}

	rotate_unit = normalize_unit(s.rotateUnit);

	if( Math.abs(s.orientation - s.targetOrientation) < rotate_unit ){
		s.orientation = s.targetOrientation;
		return;
	}

	
	if((360 - s.targetOrientation + s.orientation < 180) || (s.targetOrientation < s.orientation && s.orientation - s.targetOrientation < 180) ){
		rotate_unit = -1*rotate_unit;
	}

	new_orientation = s.orientation+rotate_unit;

	if(new_orientation < 0){
		new_orientation += 360;
	}
	
	
	new_orientation = new_orientation % 360;

	s.orientation = Math.min(new_orientation);

},

setTargetOrientation : function(){

	s = this;	

	px = s.targetX;//for test
	py = s.targetY;//for test

	if(py == s.y && px == s.x){
		return;
	}

	angle = Math.atan2(py - (s.y) , px - s.x);//+50 is center origin y
	angle = (angle * (180/Math.PI) )+90;
	if(angle < 0){
		angle+=360;
	}


	s.targetOrientation = angle;


}


};






















//define and initialize sprites/objects here

var moveObj = $("#moveObj");
var sprite = new MoveSprite(moveObj);
var mini_sprite = $("#mini_sprite");
var mini_otherCars = [];
var map = $("#map");
sprite.setSpeed(10);
//SpriteCamera(sprite,map,x_bound,y_bound,camera_speed)
var spriteCam = null;//new SpriteCamera(sprite,map,200,200,25);
var gameState = 0;//0 - game inactive; 1 - game active

//init end



// Create varaibles for init
var id;
var otherCars = [];
//init end





//game mechanic functions
function detectPop(){
	//first detect car-car collsions
	for(i = 0; i < otherCars.length; i++){
			//compute the locatoin of the tip of the needle and the center of the balloon for the two cars
			//the tip of the needle is 50 pixels left of the center and the center of the balloon is 50 pixels right of
			//the car center. Do this for each car: 
			
			balloonx = otherCars[i].car.x - (Math.sin(toRadians(otherCars[i].car.orientation))*100);
			balloony = otherCars[i].car.y + (Math.cos(toRadians(otherCars[i].car.orientation))*100);

			tipx = sprite.x + (Math.sin(toRadians(sprite.orientation))*100);
			tipy = sprite.y - (Math.cos(toRadians(sprite.orientation))*100);
			
			//if the distance between the ballon of cars[i] and the tip of cars[j] is less than radius = 50
			if( Math.sqrt(Math.pow( balloonx - tipx, 2) + Math.pow( balloony - tipy, 2))  < 45  ){
					return true;
			}
			
	}
	return false;
}













//game loop
/////////////////////
function gameLoop(fps){

	//stop if game is not active
	if(gameState == 0){
		return;
	}
trackFps();
	time_ms=1000/fps;
	setTimeout((function(){

//do game logic here:
////////////////////

//show fps
//$("#fps_log").html(normalize_unit(5)+" ================ "+real_fps+" =========== "+sprite.orientation+" ============= "+sprite.targetOrientation);
//
//fps barrier
if(real_fps > fps_barrier){

try{


//interpret user input
offset = map.offset();
target_x = mouse_x - offset.left;
target_y = mouse_y - offset.top;
sprite.setTargetPos(target_x, target_y);
//interpret user input end


sprite.setTargetOrientation();
sprite.updateOrientation();
sprite.orientSprite();
sprite.moveInDirection();
spriteCam.FollowSprite();

//mini map mini sprite
mini_sprite.css({left:(sprite.x/(5000/150))+"px",top:(sprite.y/(5000/150))+"px"});





boost_percent = 0.2;
slow_percent = 0.8;

for(i = 0; i < otherCars.length; i++) {

  temp_speed_hold = otherCars[i].car.speed;
  temp_rotate_hold = otherCars[i].car.rotateUnit;

  target_cur_pos_diff = Math.pow(otherCars[i].car.targetX - otherCars[i].car.x,2) + Math.pow(otherCars[i].car.targetY - otherCars[i].car.y,2);



  if( target_cur_pos_diff > Math.pow((temp_speed_hold*2.5),2) ){

  boost_speed = temp_speed_hold + (temp_speed_hold*boost_percent);

  boost_rotate = temp_rotate_hold + (temp_rotate_hold*boost_percent);
  otherCars[i].car.setSpeed(boost_speed);
  otherCars[i].car.setRotateUnit(boost_rotate);
  }


  if(target_cur_pos_diff < Math.pow(temp_speed_hold,2)){

  boost_speed = temp_speed_hold - (temp_speed_hold*slow_percent);

  otherCars[i].car.setSpeed(boost_speed);
  }


  otherCars[i].car.setTargetOrientation();
  otherCars[i].car.updateOrientation();
  otherCars[i].car.orientSprite();
  otherCars[i].car.moveInDirection();

  otherCars[i].car.setSpeed(temp_speed_hold);
  otherCars[i].car.setRotateUnit(temp_rotate_hold);

  //if cars are too much out of sync
  if(target_cur_pos_diff > Math.pow(temp_speed_hold*5,2)){
  otherCars[i].car.setPos(otherCars[i].car.targetX, otherCars[i].car.targetY);
  otherCars[i].car.orientation = otherCars[i].car.targetOrientation;
  }

  mini_otherCars[i].css({left:(otherCars[i].car.x/(5000/150))+"px",top:(otherCars[i].car.y/(5000/150))+"px"});
}


socket.emit("position", {x:sprite.x, y:sprite.y, orientation:sprite.orientation});

//check collision
if(detectPop()){
socket.emit("pop", {id:id});
}



}catch(e){
alert(e);
}


}//fps barrier end
//controls------------------



//controls end-------------

////////////////////
	//recursive call
	gameLoop(fps);

	}), time_ms);

return;
}//game loop end
////////////////////













$(document).ready(function(){




$("#go_animation").click(function(){

gameState = 1 - gameState;
gameLoop(start_fps);


});

/*
$("#gameView").click(function(e){
spriteCam.toggleFollow();
});
*/



$("#gameView").mousemove(function(e){
try{
mouse_x = e.pageX;
mouse_y = e.pageY;
}catch(e){
alert(e);
}

});




});














// Create varaibles for init
var id;
var otherCars = [];


socket.on('id', function(newCar){

	//console.log(newCar);
	if (newCar == null) {
		alert("username already taken or too long");
		return;
	}
	// Set our players id
	id = newCar.id;
	// Update our cars position

	$("#my_name").html(newCar.nickname);

	sprite.setPos(newCar.x,newCar.y);

	sprite.orientation = newCar.orientation;
	sprite.targetOrientation = newCar.orientation;
	sprite.orientSprite();

	// Upadate our camera's position
	spriteCam = null;
	spriteCam = new SpriteCamera(sprite,map,200,200,20);
	//Reset Score
	sprite.setScore(0);
	$("#splashscreen").fadeOut(500);
	

	gameState = 1 - gameState;
	gameLoop(start_fps);
	
});

socket.on('update', function(lists) {
if(gameState == 0){
	return;
}
lboard = "Scoreboard<br/>";

//Update Leaderboard
for(i = 0; i < lists.cars.length; i++){
num = i+ 1;
lboard += "#"+num+ " " + lists.cars[i].nickname + " " + lists.cars[i].score+"<br/>";
if(i==10){
	break;
	}
}
$("#leaderboard").html(lboard);
  //console.log("recieved update from the server.\n List of cars: ");
try{
var still_alive = 0;
	// Upadate our list of other players
  for(i = 0; i < lists.cars.length; i++){
    updatingCar = lists.cars[i];

    if (updatingCar.id == id) {
      //console.log(id);
      //sprite.setPos(updatingCar.x, updatingCar.y);
	  sprite.setScore(updatingCar.score);
      sprite.setSpeed(updatingCar.speed);
      still_alive = 1;
      continue;
    }

    //Check if this player is already in our array
    var found = false;
    for(j = 0; j < otherCars.length; j++) {
      //console.log("listCar: "+updatingCar.id + " CarID:" + otherCars[j].id);
      // update it's values if it is
      if(updatingCar.id == otherCars[j].id) {

        otherCars[j].car.setTargetPos(updatingCar.x, updatingCar.y);
        otherCars[j].car.setSpeed(updatingCar.speed);
        //$("#fps_log").html("X:"+otherCars[j].car.x+" ======== Y:"+otherCars[j].car.y);
        found = true;
        break;
      }
    }
    // If it wasn't found add the new player to our array
    if (!found) {
      otherCar = $('<div class="opponentCar"><div class="pin"></div><div class="balloon"></div><div class="player_name">'+updatingCar.nickname+'</div></div>').appendTo("#map");
      var newCar = new MoveSprite(otherCar);
      newCar.setSpeed(10);
      newCar.setPos(updatingCar.x,updatingCar.y);
      newCar.orientation = updatingCar.orientation;
      newCar.targetOrientation = updatingCar.orientation;
      otherCars.push({id:updatingCar.id, car:newCar});

      mini_otherCar = $('<div class="mini_otherCars"></div>').appendTo("#miniMap");
      mini_otherCars.push(mini_otherCar);
    }
  }



if(still_alive == 0){
	gameState = 0;
	$("#splashscreen").fadeIn(500);
	
}

//check dead
for(i = 0; i < otherCars.length; i++) {

var found = false;
for(j = 0; j < lists.cars.length; j++){

	if(otherCars[i].id == lists.cars[j].id){
		found = true;
		break;
	}

}

if(!found){//if not found remove from dom
	otherCars[i].car.sprite.remove();
	otherCars.splice(i,1);
	mini_otherCars[i].remove();
	mini_otherCars.splice(i,1);
}

}





}catch(e){
alert(e);
}





  //console.log("Given len: "+lists.cars.length + "  our length: " + otherCars.length);
  //console.log(otherCars);
});

</script>




</div> <!-- stage end -->
</div><!-- container end -->

</body>
</html>